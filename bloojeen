#Copyright (c) 2023 Speptember 3rd Alexander Edward Bryider all rights reserved.

import numpy as np
from PIL import Image
import colorsys
import gzip
import os

# Convert data (file content or directory listing) to binary
def data_to_binary(data):
    if os.path.isdir(data):
        # If it's a directory, list the files and convert the list to binary
        file_list = '\n'.join(os.listdir(data))
        binary_data = ''.join(format(ord(char), '08b') for char in file_list)
    else:
        # If it's a file, read the file content and convert it to binary
        with open(data, 'rb') as file:
            file_content = file.read()
        binary_data = ''.join(format(byte, '08b') for byte in file_content)
    return binary_data

# Convert binary data to text
def binary_to_text(binary_data):
    text = ''.join(chr(int(binary_data[i:i+8], 2)) for i in range(0, len(binary_data), 8))
    return text

# Compress text data using gzip
def compress_data(text):
    with gzip.open("compressed_data.gz", "wb") as f:
        f.write(text.encode())

# Decompress data using gzip
def decompress_data():
    with gzip.open("compressed_data.gz", "rb") as f:
        decompressed_data = f.read()
    return decompressed_data.decode()

# Embed compressed data into a Sierpinski Carpet with infinite canvas
def embed_compressed_data(carpet, compressed_data, metadata_degrees, data_values):
    carpet_data = carpet.load()
    data_index = 0

    for y in range(carpet.size[1]):
        for x in range(carpet.size[0]):
            # Get the color values for the pixel
            r, g, b = carpet_data[x, y]

            # Embed a bit of compressed data into the least significant bit of each color channel
            if data_index < len(compressed_data):
                bit = int(compressed_data[data_index])  # Extract one bit from the compressed data
                r = (r & 0xFE) | bit

                # Adjust pixel color based on metadata and dynamic data values
                degree = metadata_degrees[data_index % len(metadata_degrees)]
                h, s, v = colorsys.rgb_to_hsv(r / 255.0, g / 255.0, b / 255.0)
                h = (h + degree / 360) % 1.0
                v = data_values[data_index % len(data_values)]
                r, g, b = [int(val * 255) for val in colorsys.hsv_to_rgb(h, s, v)]

                data_index += 1

            # Update the pixel with the modified color values
            carpet_data[x, y] = (r, g, b)

    return carpet

# Extract compressed data from a Sierpinski Carpet with infinite canvas
def extract_compressed_data(carpet, compressed_data_length, metadata_degrees, data_values):
    carpet_data = carpet.load()
    extracted_compressed_data = []

    for y in range(carpet.size[1]):
        for x in range(carpet.size[0]):
            # Get the color values for the pixel
            r, _, _ = carpet_data[x, y]

            # Extract the least significant bit as compressed data
            bit = r & 0x01
            extracted_compressed_data.append(str(bit))

            if len(extracted_compressed_data) >= compressed_data_length:
                break

        if len(extracted_compressed_data) >= compressed_data_length:
            break

    return ''.join(extracted_compressed_data)

# Define canvas_section_size and zoom factors
canvas_section_size = 256
zoom_factor = 0.004  # Set the desired zoom factor

data_path = input("input the file or directory path you want to compress, and/or decompress:")  # Replace with the path to your file or directory
original_data = data_to_binary(data_path)

carpet_size = 256
num_colors = 5  # Number of equidistant colors

metadata_degrees = [i * 360 / num_colors for i in range(num_colors)]

# Generate dynamic data_values based on your requirements
data_values = [0.25, 0.5, 0.75]  # Example data_values

# Compress text data using gzip
compress_data(original_data)

new_width = int(carpet_size * zoom_factor)
new_height = int(carpet_size * zoom_factor)

if new_width > 0 and new_height > 0:
    carpet = Image.new("RGB", (carpet_size, carpet_size), (0, 0, 0))
    carpet = carpet.resize(
        (new_width, new_height),
        Image.LANCZOS
    )

    # Embed compressed data iteratively with an infinite canvas
    with open("compressed_data.gz", "rb") as compressed_file:
        compressed_data = compressed_file.read()

    embedded_canvas = embed_compressed_data(carpet.copy(), compressed_data, metadata_degrees, data_values)
    carpet.paste(embedded_canvas, (0, 0))

    # Extract compressed data from the entire carpet
    extracted_compressed_data = extract_compressed_data(carpet, len(compressed_data) * 8, metadata_degrees, data_values)

    # Convert the extracted compressed data back to bytes
    extracted_bytes_data = bytes(int(extracted_compressed_data[i:i+8], 2) for i in range(0, len(extracted_compressed_data), 8))

    # Decompress the data
    extracted_text = decompress_data()

    print(f"Zoom Factor: {zoom_factor:.4f}")
    compression_ratio = len(original_data) / len(extracted_bytes_data)
    print(f"Compression Ratio: {compression_ratio:.8f}")
    if original_data == extracted_text:
        print("Success!")
    print()
    #save the image to the current directory
    carpet.save("carpet.png")
else:
    print("Error: The zoom factor is too small.")

